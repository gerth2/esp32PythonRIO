<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Time Series Plot</title>
  <style>
    body { display: flex; font-family: Arial, sans-serif; margin: 0; }
    #sidebar { width: 200px; padding: 10px; border-right: 1px solid #ccc; background: #f9f9f9; }
    #plot-container { flex-grow: 1; position: relative; }
    canvas { width: 100%; height: 100%; display: block; }
  </style>
</head>
<body>
  <div id="sidebar">
    <h3>Signals</h3>
    <div id="signal-list"></div>
  </div>
  <div id="plot-container">
    <canvas id="plot"></canvas>
  </div>

  <script>
    let rawData = [];
    let signals = [];
    let selectedSignals = new Set();
    let lastTimeReceived = 0;

    const canvas = document.getElementById("plot");
    const ctx = canvas.getContext("2d");

    function resizeCanvas() {
      canvas.width = canvas.clientWidth;
      canvas.height = canvas.clientHeight;
      drawPlot();
    }

    function drawPlot() {
      if (selectedSignals.size === 0 || rawData.length === 0) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        return;
      }

      const times = rawData.map(d => d.TIME);
      const selectedData = rawData.map(d => {
        let entry = { TIME: d.TIME };
        selectedSignals.forEach(s => entry[s] = d[s]);
        return entry;
      });

      const allValues = selectedData.flatMap(d =>
        Object.entries(d)
          .filter(([k, v]) => k !== "TIME" && typeof v === "number")
          .map(([_, v]) => v)
      );

      const minValue = Math.min(...allValues);
      const maxValue = Math.max(...allValues);

      const margin = 40;
      const width = canvas.width - 2 * margin;
      const height = canvas.height - 2 * margin;

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.strokeStyle = "#000";
      ctx.strokeRect(margin, margin, width, height);

      const xScale = time => margin + ((time - times[0]) / (times[times.length - 1] - times[0])) * width;
      const yScale = value => margin + height - ((value - minValue) / (maxValue - minValue)) * height;

      ctx.fillStyle = "#000";
      ctx.fillText("Time (s)", canvas.width / 2, canvas.height - 5);
      ctx.fillText(`Y (${minValue.toFixed(2)} - ${maxValue.toFixed(2)})`, 5, margin - 10);

      const colors = ["red", "blue", "green", "orange", "purple", "brown", "magenta", "teal"];
      let colorIndex = 0;

      selectedSignals.forEach(signal => {
        ctx.strokeStyle = colors[colorIndex % colors.length];
        ctx.beginPath();
        selectedData.forEach((d, i) => {
          const x = xScale(d.TIME);
          const y = yScale(d[signal]);
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        });
        ctx.stroke();
        colorIndex++;
      });
    }

    function createCheckboxes() {
      const container = document.getElementById("signal-list");
      const oldSelections = new Set(selectedSignals);
      container.innerHTML = "";
      signals.forEach(signal => {
        const label = document.createElement("label");
        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.value = signal;
        checkbox.checked = oldSelections.has(signal);
        checkbox.onchange = () => {
          if (checkbox.checked) selectedSignals.add(signal);
          else selectedSignals.delete(signal);
          drawPlot();
        };
        label.appendChild(checkbox);
        label.appendChild(document.createTextNode(" " + signal));
        container.appendChild(label);
        container.appendChild(document.createElement("br"));
      });
    }

    async function fetchData() {
      try {
        const url = `/getData?since=${lastTimeReceived}`;
        const res = await fetch(url);
        const newSamples = await res.json();
        if (!Array.isArray(newSamples) || newSamples.length === 0) return;

        // Ensure TIME is sorted
        newSamples.sort((a, b) => a.TIME - b.TIME);

        // Avoid duplicate timestamps
        newSamples.forEach(sample => {
          if (sample.TIME > lastTimeReceived) {
            rawData.push(sample);
            lastTimeReceived = sample.TIME;
          }
        });

        // Update signals if necessary
        if (rawData.length > 0) {
          const latestKeys = Object.keys(rawData[rawData.length - 1]).filter(k => k !== "TIME");
          if (JSON.stringify(latestKeys.sort()) !== JSON.stringify(signals.sort())) {
            signals = latestKeys;
            createCheckboxes();
          }
        }

        drawPlot();
      } catch (err) {
        console.error("Fetch error:", err);
      }
    }

    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    fetchData(); // initial fetch
    setInterval(fetchData, 2000); // poll every 2s
  </script>
</body>
</html>
